<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="../style.css">

</head>

<body>
    <div class="main-container">
        <div class="nav-bar">
            <div class="logo">
                <a href="../../../index.html"><img src="../../../img/Typescript_logo_2020.svg.png"
                        alt="typescript-logo"></a>
            </div>
            <div class="menu-bar">
                <span><a href="../../../thisisDocs/Get-Started/ts-for-new/document.html">Get Started</a></span>
                <span><a href="../../../thisisDocs/Handbook/The TS Handbook/Document.html">Handbook</a></span>
                <span><a href="../../../reference/reference.html">Reference</a></span>
            </div>
        </div>

        <div class="tooth">
            <img src="../../../img/toothless-dancing-gif.gif" alt="toothless-dance">
        </div>
        
        <div class="grid-container">
            <div class="sidebar">
                <div class="menu" id="menu-1">
                    <div class="title-menu">Get Started</div>
                    <div class="sub-menu">
                        <a href="../../Get-Started/ts-for-new/document.html">TS for New Programmer</a>
                        <a href="../../Get-Started/ts-for-js/document.html">TS for JS Programmer</a>
                        <a href="../../Get-Started/ts-tooling/document.html">TS Tooling in 5 minutes</a>
                    </div>
                </div>
                <div class="menu" id="menu-2">
                    <div class="title-menu">Handbook</div>
                    <div class="sub-menu">
                        <a href="../The TS Handbook/Document.html">The TypeScript Handbook</a>
                        <a href="../The Basics/Document.html">The Basics</a>
                        <a href="../Everyday/Document.html">Everyday Types</a>
                    </div>
                </div>
            </div>
    
            <div class="main-content">
                <h1>The Basics</h1>
                <p>
                    Each and every value in JavaScript has a set of behaviors you can observe from running 
                    different operations. That sounds abstract, but as a quick example, consider some operations 
                    we might run on a variable named <b>message</b>.
                </p>
                <img src="../../../img/basics/b1.png" alt="code-1">
                <p>
                    If we break this down, the first runnable line of code accesses a property 
                    called <b>toLowerCase</b> and then calls it. The second one tries to call <b>message</b> directly.
                </p>
                <p>
                    But assuming we don’t know the value of <b>message</b> - and that’s pretty common - we can’t reliably say what 
                    results we’ll get from trying to run any of this code. The behavior of each operation depends 
                    entirely on what value we had in the first place.
                </p>
                <ul>
                    <li>Is <b>message</b> callable?</li>
                    <li>Does it have a property called <b>toLowerCase</b> on it?</li>
                    <li>If it does, is <b>toLowerCase</b> even callable?</li>
                    <li>If both of these values are callable, what do they return?</li>
                </ul>
                <p>
                    The answers to these questions are usually things we keep in our heads when we write JavaScript, and 
                    we have to hope we got all the details right.
                </p>
                <p>
                    Let’s say <b>message</b> was defined in the following way.
                </p>
                <img src="../../../img/basics/b2.png" alt="code-2">
                <p>
                    As you can probably guess, if we try to run <b>message.toLowerCase()</b>, we’ll get the same string only in lower-case.
                </p>
                <p>
                    What about that second line of code? If you’re familiar with JavaScript, you’ll know this fails with an exception:
                </p>
                <img src="../../../img/basics/b3.png" alt="code-3">
                <p>
                    It’d be great if we could avoid mistakes like this.
                </p>
                <p>
                    When we run our code, the way that our JavaScript runtime chooses what to do is by figuring out the type of the value - what sorts 
                    of behaviors and capabilities it has. That’s part of what that <b>TypeError</b> is alluding to - it’s saying that the 
                    string <b>"Hello World!"</b> cannot be called as a function.
                </p>
                <p>
                    For some values, such as the primitives <b>string</b> and <b>number</b>, we can identify their type at runtime using the <b>typeof</b> 
                    operator. But for other things like functions, there’s no corresponding runtime mechanism to identify their types. For example, 
                    consider this function:
                </p>
                <img src="../../../img/basics/b4.png" alt="code-4">
                <p>
                    We can observe by reading the code that this function will only work if given an object with a callable <b>flip</b> property, but JavaScript doesn’t 
                    surface this information in a way that we can check while the code is running. The only way in pure JavaScript to tell what <b>fn</b> does with a 
                    particular value is to call it and see what happens. This kind of behavior makes it hard to predict what the code will do before it runs, which 
                    means it’s harder to know what your code is going to do while you’re writing it.
                </p>
                <p>
                    Seen in this way, a <i>type</i> is the concept of describing which values can be passed to <b>fn</b> and which will crash. 
                    JavaScript only truly provides <i>dynamic</i> typing - running the code to see what happens.
                </p>
                <p>
                    The alternative is to use a <i>static</i> type system to make predictions about what the code is expected to do before it runs.
                </p>

                <h2>Static type-checking</h2>
                <p>
                    Think back to that <b>TypeError</b> we got earlier from trying to call a <b>string</b> as a function. <i>Most people</i> don’t like to get any sorts of 
                    errors when running their code - those are considered bugs! And when we write new code, we try our best to avoid introducing new bugs.
                </p>
                <p>
                    If we add just a bit of code, save our file, re-run the code, and immediately see the error, we might be able to isolate the problem quickly; 
                    but that’s not always the case. We might not have tested the feature thoroughly enough, so we might never actually run into a potential error 
                    that would be thrown! Or if we were lucky enough to witness the error, we might have ended up doing large refactorings and adding a lot of 
                    different code that we’re forced to dig through.
                </p>
                <p>
                    Ideally, we could have a tool that helps us find these bugs before our code runs. That’s what a static type-checker like TypeScript does. 
                    <i>Static types</i> systems describe the shapes and behaviors of what our values will be when we run our programs. 
                    A type-checker like TypeScript uses that information and tells us when things might be going off the rails.
                </p>
                <img src="../../../img/basics/b5.png" alt="code-5">
                <p>
                    Running that last sample with TypeScript will give us an error message before we run the code in the first place.
                </p>

                <h2>Non-exception Failures</h2>
                <p>
                    So far we’ve been discussing certain things like runtime errors - cases where the JavaScript runtime tells us that it thinks something is nonsensical. 
                    Those cases come up because the ECMAScript specification has explicit instructions on how the language should behave when it runs into something unexpected.
                </p>
                <p>
                    For example, the specification says that trying to call something that isn’t callable should throw an error. Maybe that sounds like “obvious behavior”, but you 
                    could imagine that accessing a property that doesn’t exist on an object should throw an error too. Instead, JavaScript 
                    gives us different behavior and returns the value <b>undefined</b>:
                </p>
                <img src="../../../img/basics/b6.png" alt="code-6">
                <p>
                    Ultimately, a static type system has to make the call over what code should be flagged as an error in its system, even if it’s “valid” JavaScript that won’t 
                    immediately throw an error. In TypeScript, the following code produces an error about <b>location</b> not being defined:
                </p>
                <img src="../../../img/basics/b7.png" alt="code-7">
                <p>
                    While sometimes that implies a trade-off in what you can express, the intent is to catch legitimate bugs in our programs. 
                    And TypeScript catches <i>a lot</i> of legitimate bugs.
                </p>
                <p>
                    For example: typos,
                </p>
                <img src="../../../img/basics/b8.png" alt="code-8">
                <p>
                    uncalled functions,
                </p>
                <img src="../../../img/basics/b9.png" alt="code-9">
                <p>
                    or basic logic errors.
                </p>
                <img src="../../../img/basics/b10.png" alt="code-10">

                <h2>Types for Tooling</h2>
                <p>
                    TypeScript can catch bugs when we make mistakes in our code. That’s great, but TypeScript can <i>also</i> 
                    prevent us from making those mistakes in the first place.
                </p>
                <p>
                    The type-checker has information to check things like whether we’re accessing the right properties on 
                    variables and other properties. Once it has that information, it can also start suggesting which 
                    properties you might want to use.
                </p>
                <p>
                    That means TypeScript can be leveraged for editing code too, and the core type-checker can provide error 
                    messages and code completion as you type in the editor. That’s part of what people often refer to 
                    when they talk about tooling in TypeScript.
                </p>
                <img src="../../../img/basics/b11.png" alt="code-11">
                <p>
                    TypeScript takes tooling seriously, and that goes beyond completions and errors as you type. An editor that 
                    supports TypeScript can deliver “quick fixes” to automatically fix errors, refactorings to easily re-organize 
                    code, and useful navigation features for jumping to definitions of a variable, or finding all references to a 
                    given variable. All of this is built on top of the type-checker and is fully cross-platform, so it’s likely 
                    that your favorite editor has TypeScript support available.
                </p>

                <h2>tsc, the TypeScript compiler</h2>
                <p>
                    We’ve been talking about type-checking, but we haven’t yet used our type-checker. Let’s get acquainted with 
                    our new friend <b>tsc</b>, the TypeScript compiler. First we’ll need to grab it via npm.
                </p>
                <img src="../../../img/basics/b12.png" alt="code-12">
                <p>
                    Now let’s move to an empty folder and try writing our first TypeScript program: <b>hello.ts</b>:
                </p>
                <img src="../../../img/basics/b13.png" alt="code-13">
                <p>
                    Notice there are no frills here; this “hello world” program looks identical to what you’d write for a “hello world” 
                    program in JavaScript. And now let’s type-check it by running the command <b>tsc</b> which was installed for 
                    us by the <b>typescript</b> package.
                </p>
                <img src="../../../img/basics/b14.png" alt="code-14">
                <p>
                    Tada!
                </p>
                <p>
                    Wait, “tada” <i>what</i> exactly? We ran <b>tsc</b> and nothing happened! Well, there were no type errors, so we didn’t get any output 
                    in our console since there was nothing to report.
                </p>
                <p>
                    But check again - we got some file output instead. If we look in our current directory, we’ll see a <b>hello.js</b> file next to <b>hello.ts</b>. 
                    That’s the output from our <b>hello.ts</b> file after <b>tsc</b> compiles or transforms it into a plain JavaScript file. And if we check the contents, we’ll 
                    see what TypeScript spits out after it processes a <b>.ts</b> file:
                </p>
                <img src="../../../img/basics/b15.png" alt="code-15">
                <p>
                    In this case, there was very little for TypeScript to transform, so it looks identical to what we wrote. The compiler tries to 
                    emit clean readable code that looks like something a person would write. While that’s not always so easy, TypeScript indents 
                    consistently, is mindful of when our code spans across different lines of code, and tries to keep comments around.
                </p>
                <p>
                    What about if <i>we did</i> introduce a type-checking error? Let’s rewrite <b>hello.ts</b>:
                </p>
                <img src="../../../img/basics/b16.png" alt="code-16">
                <p>
                    If we run <b>tsc hello.ts</b> again, notice that we get an error on the command line!
                </p>
                <img src="../../../img/basics/b17.png" alt="code-17">
                <p>
                    TypeScript is telling us we forgot to pass an argument to the <b>greet</b> function, and rightfully so. So far we’ve 
                    only written standard JavaScript, and yet type-checking was still able to find problems with our code. Thanks TypeScript!
                </p>

                <h2>Emitting with Errors</h2>
                <p>
                    One thing you might not have noticed from the last example was that our <b>hello.js</b> file changed again. If we open that file up 
                    then we’ll see that the contents still basically look the same as our input file. That might be a bit surprising given the fact 
                    that <b>tsc</b> reported an error about our code, but this is based on one of TypeScript’s core values: much of the time, you will know 
                    better than TypeScript.
                </p>
                <p>
                    To reiterate from earlier, type-checking code limits the sorts of programs you can run, and so there’s a tradeoff on what sorts 
                    of things a type-checker finds acceptable. Most of the time that’s okay, but there are scenarios where those checks get in the way. 
                    For example, imagine yourself migrating JavaScript code over to TypeScript and introducing type-checking errors. Eventually you’ll 
                    get around to cleaning things up for the type-checker, but that original JavaScript code was already working! Why should converting 
                    it over to TypeScript stop you from running it?
                </p>
                <p>
                    So TypeScript doesn’t get in your way. Of course, over time, you may want to be a bit more defensive against mistakes, and make 
                    TypeScript act a bit more strictly. In that case, you can use the noEmitOnError compiler option. 
                    Try changing your <b>hello.ts</b> file and running <b>tsc</b> with that flag:
                </p>
                <img src="../../../img/basics/b18.png" alt="code-18">
                <p>
                    You’ll notice that <b>hello.js</b> never gets updated.
                </p>

                <h2>Explicit Types</h2>
                <p>
                    Up until now, we haven’t told TypeScript what <b>person</b> or <b>date</b> are. Let’s edit the code to tell TypeScript that <b>person</b> is 
                    a <b>string</b>, and that <b>date</b> should be a <b>Date</b> object. We’ll also use the <b>toDateString()</b> method on <b>date</b>.
                </p>
                <img src="../../../img/basics/b19.png" alt="code-19">
                <p>
                    What we did was add type annotations on <b>person</b> and <b>date</b> to describe what types of values <b>greet</b> can be called with. 
                    You can read that signature as ”<b>greet</b> takes a <b>person</b> of type <b>string</b>, and a <b>date</b> of type <b>Date</b>“.
                </p>
                <p>
                    With this, TypeScript can tell us about other cases where <b>greet</b> might have been called incorrectly. For example…
                </p>
                <img src="../../../img/basics/b20.png" alt="code-20">
                <p>
                    Huh? TypeScript reported an error on our second argument, but why?
                </p>
                <p>
                    Perhaps surprisingly, calling <b>Date()</b> in JavaScript returns a <b>string</b>. On the other hand, 
                    constructing a <b>Date</b> with <b>new Date()</b> actually gives us what we were expecting.
                </p>
                <p>
                    Anyway, we can quickly fix up the error:
                </p>
                <img src="../../../img/basics/b21.png" alt="code-21">
                <p>
                    Keep in mind, we don’t always have to write explicit type annotations. In many cases, TypeScript can even 
                    just <i>infer</i> (or “figure out”) the types for us even if we omit them.
                </p>
                <img src="../../../img/basics/b22.png" alt="code-22">
                <p>
                    Even though we didn’t tell TypeScript that <b>msg</b> had the type <b>string</b> it was able to figure that out. That’s a feature, and it’s 
                    best not to add annotations when the type system would end up inferring the same type anyway.
                </p>

                <h2>Erased Types</h2>
                <p>
                    Let’s take a look at what happens when we compile the above function <b>greet</b> with <b>tsc</b> to output JavaScript:
                </p>
                <img src="../../../img/basics/b23.png" alt="code-23">
                <p>
                    Notice two things here:
                </p>
                <ol>
                    <li>Our <b>person</b> and <b>date</b> parameters no longer have type annotations.</li>
                    <li>Our “template string” - that string that used backticks (the <b>`</b> character) - was converted to plain strings with concatenations.</li>
                </ol>
                <p>
                    More on that second point later, but let’s now focus on that first point. Type annotations aren’t part of JavaScript (or ECMAScript to be pedantic), 
                    so there really aren’t any browsers or other runtimes that can just run TypeScript unmodified. That’s why TypeScript needs a compiler in the first place - 
                    it needs some way to strip out or transform any TypeScript-specific code so that you can run it. Most TypeScript-specific code gets erased away, and 
                    likewise, here our type annotations were completely erased.
                </p>
                
                <h2>Downleveling</h2>
                <p>
                    One other difference from the above was that our template string was rewritten from
                </p>
                <img src="../../../img/basics/b24.png" alt="code-24">
                <p>
                    to
                </p>
                <img src="../../../img/basics/b25.png" alt="code-25">
                <p>
                    Why did this happen?
                </p>
                <p>
                    Template strings are a feature from a version of ECMAScript called ECMAScript 2015 (a.k.a. ECMAScript 6, ES2015, ES6, etc. - <i>don’t ask</i>). 
                    TypeScript has the ability to rewrite code from newer versions of ECMAScript to older ones such as ECMAScript 3 or ECMAScript 5 
                    (a.k.a. ES3 and ES5). This process of moving from a newer or “higher” version of ECMAScript down to an older or “lower” one is 
                    sometimes called <i>downleveling</i>.
                </p>
                <p>
                    By default TypeScript targets ES3, an extremely old version of ECMAScript. We could have chosen something a little bit more recent 
                    by using the <b>target</b> option. Running with <b>--target es2015</b> changes TypeScript to target ECMAScript 2015, meaning code should be able 
                    to run wherever ECMAScript 2015 is supported. So running tsc <b>--target es2015 hello.ts</b> gives us the following output:
                </p>
                <img src="../../../img/basics/b26.png" alt="code-26">

                <h2>Strictness</h2>
                <p>
                    Different users come to TypeScript looking for different things in a type-checker. Some people are looking for a more loose opt-in 
                    experience which can help validate only some parts of their program, and still have decent tooling. This is the default experience 
                    with TypeScript, where types are optional, inference takes the most lenient types, and there’s no checking for potentially <b>null/undefined</b> 
                    values. Much like how <b>tsc</b> emits in the face of errors, these defaults are put in place to stay out of your way. If you’re migrating 
                    existing JavaScript, that might be a desirable first step.
                </p>
                <p>
                    In contrast, a lot of users prefer to have TypeScript validate as much as it can straight away, and that’s why the 
                    language provides strictness settings as well. These strictness settings turn static type-checking from a switch 
                    (either your code is checked or not) into something closer to a dial. The further you turn this dial up, the more 
                    TypeScript will check for you. This can require a little extra work, but generally speaking it pays for itself in 
                    the long run, and enables more thorough checks and more accurate tooling. When possible, a new codebase should always 
                    turn these strictness checks on.
                </p>
                <p>
                    TypeScript has several type-checking strictness flags that can be turned on or off, and all of our examples 
                    will be written with all of them enabled unless otherwise stated. The <b>strict</b> flag in the CLI, or <b>"strict": true</b> 
                    in a tsconfig.json toggles them all on simultaneously, but we can opt out of them individually. The two biggest 
                    ones you should know about are <b>noImplicitAny</b> and <b>strictNullChecks</b>.
                </p>
                <ul>
                    <li>
                        <h2>strictNullChecks</h2>
                        <p>
                            Recall that in some places, TypeScript doesn’t try to infer types for us and instead falls 
                            back to the most lenient type: <b>any</b>. This isn’t the worst thing that can happen - after all, 
                            falling back to <b>any</b> is just the plain JavaScript experience anyway.
                        </p>
                        <p>
                            However, using <b>any</b> often defeats the purpose of using TypeScript in the first place. 
                            The more typed your program is, the more validation and tooling you’ll get, meaning you’ll 
                            run into fewer bugs as you code. Turning on the <b>noImplicitAny</b> flag will issue an error on 
                            any variables whose type is implicitly inferred as <b>any</b>.
                        </p>
                    </li>
                    <li>
                        <h2>strictNullChecks</h2>
                        <p>
                            By default, values like <b>null</b> and <b>undefined</b> are assignable to any other type. This can make 
                            writing some code easier, but forgetting to handle <b>null</b> and <b>undefined</b> is the cause of countless 
                            bugs in the world - some consider it a <b>billion dollar mistake</b>! The <b>strictNullChecks</b> flag makes 
                            handling <b>null</b> and <b>undefined</b> more explicit, and spares us from worrying about whether we forgot 
                            to handle <b>null</b> and <b>undefined</b>.
                        </p>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</body>

</html>